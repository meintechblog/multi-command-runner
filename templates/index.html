<!doctype html>
<html lang="de">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>multi-command-runner</title>
    <link rel="stylesheet" href="/static/style.css?v={{ asset_version }}" />
  </head>
  <body>
    <div class="wrap">
      <header class="row between center" id="topHeader">
        <h1 id="openInfoTitle" class="titleInfoTrigger" role="button" tabindex="0" title="Öffnet die Programm-Info">multi-command-runner</h1>
        <div class="headerRight">
          <div id="flashDock">
            <div id="uiFlash" class="flash info" aria-live="polite"></div>
          </div>
          <button id="langToggleBtn" class="btn langToggle" type="button" aria-label="Sprache" title="DE/EN/FR/中文">DE</button>
        </div>
      </header>

      <section class="card">
        <div class="row between center" style="margin-bottom:12px;">
          <div class="row gap center">
            <span id="notifySectionToggle" class="toggle">-</span>
            <h2 id="notifySectionTitle" style="margin:0;">Notification services</h2>
          </div>
          <div class="row gap center wrapline">
            <button id="sortNotifyBtn" class="btn">Sortieren: Aus</button>
            <button id="addNotifyBtn" class="btn primary">+ Dienst</button>
          </div>
        </div>
        <div id="notifySectionBody">
          <div id="notifyProfiles"></div>
        </div>
      </section>

	      <section class="card">
	        <div class="row between center wrapline" style="margin-bottom:12px;">
	          <div class="row gap center">
	            <span id="runnerSectionToggle" class="toggle">-</span>
	            <h2 id="runnerSectionTitle" style="margin:0;">Runners</h2>
              <div class="row gap center hidden" id="runningStatus" role="status" aria-live="polite" aria-atomic="true">
                <div class="spinner hidden" id="globalSpinner"></div>
                <span id="runningCount"></span>
              </div>
	          </div>
	          <div class="row gap wrapline">
	            <button id="sortRunnerBtn" class="btn">Sortieren: Aus</button>
	            <button id="exportBtn" class="btn">⬇ Export</button>
	            <button id="importBtn" class="btn">⬆ Import</button>
	            <button id="addGroupBtn" class="btn">+ Obergruppe</button>
	            <button id="addRunnerBtn" class="btn primary">+ Runner</button>
	            <input type="file" id="importFile" accept=".json" style="display:none;" />
	          </div>
	        </div>
	        <div id="runnerSectionBody">
	          <div id="runners"></div>
	        </div>
	      </section>

	      <section class="card">
	        <div class="row between center wrapline" style="margin-bottom:10px;">
	          <div class="row gap center">
	            <span id="notifyJournalSectionToggle" class="toggle">-</span>
	            <h2 id="notifyJournalTitle" style="margin:0;">Notification journal</h2>
	          </div>
	          <button id="clearNotifyJournalBtn" class="btn danger">Journal leeren</button>
	        </div>
          <div id="notifyJournalSectionBody">
	          <pre id="notifyJournal" class="output"></pre>
          </div>
	      </section>
	
	      <section class="card">
	        <div class="row between center wrapline" style="margin-bottom:10px;">
	          <div class="row gap center">
	            <span id="eventsSectionToggle" class="toggle">-</span>
	            <h2 id="eventsTitle" style="margin:0;">Events</h2>
	          </div>
	          <button id="clearEventsBtn" class="btn danger">Events leeren</button>
	        </div>
          <div id="eventsSectionBody">
	          <pre id="events" class="output"></pre>
          </div>
	      </section>
    </div>

    <div id="infoModal" class="modal hidden" aria-hidden="true">
      <div class="modalBackdrop" data-close-info="1"></div>
      <div class="modalCard" role="dialog" aria-modal="true" aria-labelledby="infoModalTitle">
        <div class="row between center wrapline" style="gap:10px; margin-bottom:10px;">
          <h2 id="infoModalTitle" style="margin:0;">Info</h2>
          <button id="closeInfoBtn" class="btn">Schließen</button>
        </div>
        <div class="modalBody">
          <div id="infoBodyDe" data-lang="de">
            <p class="hint" style="margin:0 0 6px 0;">Version: <strong>v{{ app_version }}</strong></p>
            <p class="hint" style="margin:0 0 10px 0;">Die wichtigsten Funktionen und wie sie zusammenspielen.</p>
	            <h3>1) Runner Basis</h3>
		            <ul>
		              <li>Jeder Runner hat Name, Command, Cases, Notification-Zuordnung und Scheduler.</li>
		              <li><code>▶ Run</code> startet sofort. <code>■ Stop</code> beendet laufende Prozesse und geplante Folge-Runs.</li>
		              <li>Wenn ein Runner aktiv ist (laufend oder geplant), wird die Dauer im Format <code>hh:mm:ss</code> angezeigt (unbegrenzte Stunden).</li>
		              <li>Während ein Runner aktiv ist (laufend oder geplant), sind seine Parameter gesperrt (nur Notification-Zuordnung <code>Ein/Aus</code> und <code>Updates only</code> ist editierbar).</li>
		              <li>Ein Runner kann nur gestartet werden, wenn seine Änderungen gespeichert sind (kein Bearbeitungsmodus).</li>
		              <li>Reihenfolge kann per Sortiermodus mit <code>↑/↓</code> geändert werden (mobil-freundlich).</li>
		              <li>Änderungen markieren Speichern-Button und Eintrag dezent (<code>dirty</code>).</li>
		              <li><code>Clone</code> erstellt eine gespeicherte Kopie eines Runners direkt darunter.</li>
		              <li>Die Runner-Sektion kann oben zentral ein-/zugeklappt werden.</li>
		            </ul>
            <h3>2) Scheduler</h3>
            <ul>
              <li>Intervallfelder <code>Stunden/Minuten/Sekunden</code> planen den nächsten Run nach Run-Ende.</li>
              <li><code>Anzahl Runs</code> steuert, wie oft der Runner insgesamt laufen soll (1..100 oder <code>unendlich</code>).</li>
              <li>Bei laufendem Scheduler siehst du den Status direkt in der Runner-Zeile.</li>
            </ul>
            <h3>3) Cases (Regex) & Statuslogik</h3>
            <ul>
              <li>Jeder Case prüft Output-Zeilen mit einem Regex-Pattern.</li>
              <li>Im Template können Gruppen genutzt werden: <code>{match}</code>, <code>{g1}</code>, <code>{g2}</code>, <code>{name}</code>.</li>
              <li>Status je Case: <code>UP</code>, <code>DOWN</code>, <code>WARN</code>, <code>INFO</code> oder leer.</li>
              <li>Leerer Fallback-Case (Pattern + Template leer) sendet bei Run-Ende die letzte Output-Zeile.</li>
            </ul>
            <h3>4) Alertsteuerung (pro Runner)</h3>
            <ul>
              <li><code>Alert-Cooldown</code>: Mindestabstand zwischen wiederholten Meldungen bei unverändertem Problemstatus (<code>DOWN/WARN</code>).</li>
              <li><code>Eskalation</code>: Wenn ein Problemstatus bestehen bleibt, wird nach dieser Zeit erneut gemeldet (Eskalationsmeldung).</li>
              <li><code>Auto-Pause</code>: Pausiert den Runner nach X aufeinanderfolgenden Fehler-Runs (Exit-Code ungleich 0). 0 = aus.</li>
              <li>Recovery von <code>DOWN/WARN</code> nach <code>UP</code> wird als Recovery-Event verarbeitet.</li>
            </ul>
            <h3>5) Notification-Services</h3>
            <ul>
              <li>Mehrere Notification-Services pro Runner möglich.</li>
              <li>Pro Service: Name, User-Key, API-Token, Aktiv/Inaktiv, Testversand, Remove.</li>
              <li>Live-Status zeigt Fehlerzähler und insgesamt gesendete Nachrichten.</li>
              <li>Nach 3 aufeinanderfolgenden Versandfehlern wird ein Service automatisch deaktiviert.</li>
              <li>Pro Runner-Zuordnung: <code>Aktiv</code> und optional <code>Only updates</code> (nur Statuswechsel statt Dauerwiederholung).</li>
              <li>Zugangsdaten werden im Backend verschlüsselt gespeichert (at rest) und im API-State nur maskiert ausgeliefert.</li>
            </ul>
	            <h3>6) Output, Logs, Journal</h3>
	            <ul>
	              <li>Live-Output pro Runner inkl. <code>Copy</code>-Button.</li>
	              <li>Logdatei pro Runner: Logging an/aus, öffnen, leeren. Leere Datei wird bei Bedarf automatisch erzeugt.</li>
	              <li>Notification-Journal listet Versandhistorie inkl. Fehlerursachen; kann zentral geleert werden.</li>
	              <li>Events-Fenster zeigt Live-Aktionen und Statusänderungen aus dem Event-Stream; kann geleert werden.</li>
	            </ul>
	            <h3>7) Speichern, Validierung, Import/Export</h3>
	            <ul>
	              <li>Speichern-Button wird bei Änderungen markiert (dirty).</li>
	              <li>Ungültige Pflichtfelder markieren den Speichern-Button rot.</li>
	              <li>Neue Runner werden beim Hinzufügen direkt gespeichert. Ohne Command sind sie nicht startbar.</li>
	              <li>Notification-Services sind erst speicherbar, wenn alle Pflichtfelder gefüllt sind.</li>
	              <li>Runner können als JSON exportiert und importiert werden.</li>
	            </ul>
          </div>

          <div id="infoBodyEn" data-lang="en" class="hidden">
            <p class="hint" style="margin:0 0 6px 0;">Version: <strong>v{{ app_version }}</strong></p>
            <p class="hint" style="margin:0 0 10px 0;">Key features and how they work together.</p>

            <h3>1) Runner Basics</h3>
            <ul>
              <li>Each runner has a name, command, cases, notification assignment and scheduler.</li>
              <li><code>▶ Run</code> starts immediately. <code>■ Stop</code> stops running processes and cancels scheduled follow-up runs.</li>
              <li>When a runner is active (running or scheduled), the duration is shown as <code>hh:mm:ss</code> (unlimited hours).</li>
              <li>While a runner is active (running or scheduled), its parameters are locked (only notification assignment <code>On/Off</code> and <code>Updates only</code> is editable).</li>
              <li>A runner can only be started when its changes are saved (not in edit mode).</li>
              <li>Order can be changed via sort mode using <code>↑/↓</code> (mobile-friendly).</li>
              <li>Changes mark the save button and the entry subtly (<code>dirty</code>).</li>
              <li><code>Clone</code> creates a saved copy of a runner directly below it.</li>
              <li>The runners section can be collapsed/expanded at the top.</li>
            </ul>

            <h3>2) Scheduler</h3>
            <ul>
              <li>Interval fields <code>Hours/Minutes/Seconds</code> schedule the next run after a run finishes.</li>
              <li><code>Total runs</code> controls how many times a runner should run in total (1..100 or <code>infinite</code>).</li>
              <li>When the scheduler is active you see the status directly in the runner row.</li>
            </ul>

            <h3>3) Cases (Regex) & Status Logic</h3>
            <ul>
              <li>Each case checks output lines using a regex pattern.</li>
              <li>The template can use groups: <code>{match}</code>, <code>{g1}</code>, <code>{g2}</code>, <code>{name}</code>.</li>
              <li>Status per case: <code>UP</code>, <code>DOWN</code>, <code>WARN</code>, <code>INFO</code> or empty.</li>
              <li>An empty fallback case (empty pattern and template) sends the last output line when the run finishes.</li>
            </ul>

            <h3>4) Alerts (Per Runner)</h3>
            <ul>
              <li><code>Alert cooldown</code>: minimum time between repeated messages when the problem state stays unchanged (<code>DOWN/WARN</code>).</li>
              <li><code>Escalation</code>: if a problem state persists, send another message after this time (escalation).</li>
              <li><code>Auto pause</code>: pauses the runner after X consecutive failing runs (exit code not 0). 0 = off.</li>
              <li>Recovery from <code>DOWN/WARN</code> to <code>UP</code> is processed as a recovery event.</li>
            </ul>

            <h3>5) Notification Services</h3>
            <ul>
              <li>Multiple notification services can be assigned per runner.</li>
              <li>Per service: name, user key, API token, active/inactive, test send, remove.</li>
              <li>Live status shows failure count and total sent messages.</li>
              <li>After 3 consecutive send failures a service is automatically disabled.</li>
              <li>Per runner assignment: <code>Active</code> and optionally <code>Only updates</code> (only status changes instead of repeated messages).</li>
              <li>Credentials are stored encrypted at rest in the backend and are only returned masked in the API state.</li>
            </ul>

            <h3>6) Output, Logs, Journal</h3>
            <ul>
              <li>Live output per runner incl. <code>Copy</code> button.</li>
              <li>Log file per runner: logging on/off, open, clear. Empty files are created automatically if needed.</li>
              <li>The notification journal lists delivery history incl. failure reasons; it can be cleared centrally.</li>
              <li>The events window shows live actions and status changes from the event stream; it can be cleared.</li>
            </ul>

            <h3>7) Saving, Validation, Import/Export</h3>
            <ul>
              <li>The save button is marked when changes exist (dirty).</li>
              <li>Invalid required fields mark the save button red.</li>
              <li>New runners are saved immediately when added. Without a command they cannot be started.</li>
              <li>Notification services can only be saved when all required fields are filled.</li>
              <li>Runners can be exported and imported as JSON.</li>
            </ul>
          </div>

          <div id="infoBodyFr" data-lang="fr" class="hidden">
            <p class="hint" style="margin:0 0 6px 0;">Version: <strong>v{{ app_version }}</strong></p>
            <p class="hint" style="margin:0 0 10px 0;">Fonctionnalités principales et leur fonctionnement ensemble.</p>

            <h3>1) Bases des Runners</h3>
            <ul>
              <li>Chaque runner a un nom, une commande, des cases, une affectation de notifications et un scheduler.</li>
              <li><code>▶ Run</code> démarre immédiatement. <code>■ Stop</code> arrête les processus en cours et annule les runs planifiés.</li>
              <li>Quand un runner est actif (en cours ou planifié), la durée est affichée au format <code>hh:mm:ss</code> (heures illimitées).</li>
              <li>Tant qu'un runner est actif (en cours ou planifié), ses paramètres sont verrouillés (seule l'affectation notifications <code>On/Off</code> et <code>Updates only</code> reste modifiable).</li>
              <li>Un runner peut démarrer seulement si ses changements sont enregistrés (hors mode édition).</li>
              <li>L'ordre peut être modifié via le mode tri avec <code>↑/↓</code> (adapté mobile).</li>
              <li>Les changements marquent subtilement le bouton Save et l'entrée (<code>dirty</code>).</li>
              <li><code>Clone</code> crée une copie enregistrée du runner juste en dessous.</li>
              <li>La section runners peut être repliée/dépliée en haut.</li>
            </ul>

            <h3>2) Scheduler</h3>
            <ul>
              <li>Les champs d'intervalle <code>Hours/Minutes/Seconds</code> planifient le prochain run après la fin d'un run.</li>
              <li><code>Total runs</code> contrôle combien de fois un runner doit tourner au total (1..100 ou <code>infinite</code>).</li>
              <li>Quand le scheduler est actif, le statut apparaît directement dans la ligne du runner.</li>
            </ul>

            <h3>3) Cases (Regex) & Logique de Statut</h3>
            <ul>
              <li>Chaque case vérifie les lignes de sortie avec un motif regex.</li>
              <li>Le template peut utiliser des groupes: <code>{match}</code>, <code>{g1}</code>, <code>{g2}</code>, <code>{name}</code>.</li>
              <li>Statut par case: <code>UP</code>, <code>DOWN</code>, <code>WARN</code>, <code>INFO</code> ou vide.</li>
              <li>Un case fallback vide (pattern et template vides) envoie la dernière ligne de sortie à la fin du run.</li>
            </ul>

            <h3>4) Alertes (Par Runner)</h3>
            <ul>
              <li><code>Alert cooldown</code>: temps minimum entre messages répétés quand l'état problème reste inchangé (<code>DOWN/WARN</code>).</li>
              <li><code>Escalation</code>: si un état problème persiste, envoie un nouveau message après ce délai (escalade).</li>
              <li><code>Auto pause</code>: met le runner en pause après X runs en échec consécutifs (code de sortie non nul). 0 = off.</li>
              <li>Le retour de <code>DOWN/WARN</code> vers <code>UP</code> est traité comme un événement de recovery.</li>
            </ul>

            <h3>5) Services de Notification</h3>
            <ul>
              <li>Plusieurs services de notification peuvent être affectés par runner.</li>
              <li>Par service: nom, user key, API token, actif/inactif, test d'envoi, suppression.</li>
              <li>Le statut live affiche le compteur d'échecs et le total des messages envoyés.</li>
              <li>Après 3 échecs d'envoi consécutifs, un service est désactivé automatiquement.</li>
              <li>Par affectation runner: <code>Active</code> et option <code>Only updates</code> (seulement les changements d'état au lieu des répétitions).</li>
              <li>Les identifiants sont stockés chiffrés au repos côté backend et retournés masqués dans l'état API.</li>
            </ul>

            <h3>6) Sortie, Logs, Journal</h3>
            <ul>
              <li>Sortie live par runner avec bouton <code>Copy</code>.</li>
              <li>Fichier log par runner: logging on/off, ouvrir, vider. Les fichiers vides sont créés automatiquement si nécessaire.</li>
              <li>Le journal de notifications liste l'historique d'envoi avec les causes d'échec; il peut être vidé globalement.</li>
              <li>La fenêtre events montre les actions live et changements de statut du flux d'événements; elle peut être vidée.</li>
            </ul>

            <h3>7) Enregistrement, Validation, Import/Export</h3>
            <ul>
              <li>Le bouton Save est marqué quand des changements existent (dirty).</li>
              <li>Les champs obligatoires invalides marquent le bouton Save en rouge.</li>
              <li>Les nouveaux runners sont enregistrés immédiatement à l'ajout. Sans commande, ils ne peuvent pas démarrer.</li>
              <li>Les services de notification sont enregistrables seulement si tous les champs obligatoires sont remplis.</li>
              <li>Les runners peuvent être exportés et importés en JSON.</li>
            </ul>
          </div>

          <div id="infoBodyZh" data-lang="zh" class="hidden">
            <p class="hint" style="margin:0 0 6px 0;">版本：<strong>v{{ app_version }}</strong></p>
            <p class="hint" style="margin:0 0 10px 0;">核心功能与协作方式。</p>

            <h3>1) 运行器基础</h3>
            <ul>
              <li>每个运行器包含名称、命令、规则（Cases）、通知分配和调度器。</li>
              <li><code>▶ Run</code> 立即启动。<code>■ Stop</code> 停止当前进程并取消后续计划运行。</li>
              <li>当运行器处于活动状态（运行中或已计划）时，会显示 <code>hh:mm:ss</code> 时长（小时不受限）。</li>
              <li>运行器活动期间参数会被锁定（仅通知分配 <code>On/Off</code> 与 <code>Updates only</code> 可编辑）。</li>
              <li>运行器仅可在已保存状态下启动（非编辑模式）。</li>
              <li>可通过排序模式中的 <code>↑/↓</code> 调整顺序（移动端友好）。</li>
              <li>发生修改时，保存按钮和条目会被标记为 <code>dirty</code>。</li>
              <li><code>Clone</code> 会在下方创建该运行器的已保存副本。</li>
              <li>运行器区域可在顶部折叠/展开。</li>
            </ul>

            <h3>2) 调度器</h3>
            <ul>
              <li><code>Hours/Minutes/Seconds</code> 间隔字段用于在一次运行结束后安排下一次运行。</li>
              <li><code>Total runs</code> 控制运行总次数（1..100 或 <code>infinite</code>）。</li>
              <li>调度器激活时，状态会直接显示在运行器行内。</li>
            </ul>

            <h3>3) 规则（Regex）与状态逻辑</h3>
            <ul>
              <li>每个规则会用正则表达式检查输出行。</li>
              <li>模板可使用分组：<code>{match}</code>、<code>{g1}</code>、<code>{g2}</code>、<code>{name}</code>。</li>
              <li>每条规则的状态可设为：<code>UP</code>、<code>DOWN</code>、<code>WARN</code>、<code>INFO</code> 或留空。</li>
              <li>空的兜底规则（pattern 和 template 为空）会在运行结束时发送最后一行输出。</li>
            </ul>

            <h3>4) 告警控制（每个运行器）</h3>
            <ul>
              <li><code>Alert cooldown</code>：当问题状态不变（<code>DOWN/WARN</code>）时，重复消息之间的最小间隔。</li>
              <li><code>Escalation</code>：若问题持续存在，在该时间后再次发送消息（升级通知）。</li>
              <li><code>Auto pause</code>：连续失败 X 次后自动暂停（退出码不为 0）。0 = 关闭。</li>
              <li>从 <code>DOWN/WARN</code> 恢复到 <code>UP</code> 会作为恢复事件处理。</li>
            </ul>

            <h3>5) 通知服务</h3>
            <ul>
              <li>每个运行器可分配多个通知服务。</li>
              <li>每个服务包含：名称、User Key、API Token、启用/禁用、测试发送、删除。</li>
              <li>实时状态会显示失败计数和累计发送量。</li>
              <li>连续 3 次发送失败后，服务会自动禁用。</li>
              <li>运行器分配支持：<code>Active</code> 和可选 <code>Only updates</code>（仅状态变化，不重复发送）。</li>
              <li>凭据在后端静态加密存储，API 返回时只提供掩码值。</li>
            </ul>

            <h3>6) 输出、日志、Journal</h3>
            <ul>
              <li>每个运行器都有实时输出，并带 <code>Copy</code> 按钮。</li>
              <li>每个运行器独立日志：logging 开/关、打开、清空。需要时会自动创建空日志文件。</li>
              <li>通知日志记录发送历史与失败原因，可统一清空。</li>
              <li>事件窗口显示事件流中的实时动作与状态变化，可清空。</li>
            </ul>

            <h3>7) 保存、校验、导入/导出</h3>
            <ul>
              <li>有改动时，保存按钮会被标记（dirty）。</li>
              <li>必填项校验失败时，保存按钮会显示红色标记。</li>
              <li>新增运行器会在添加时立即保存。无命令时不可启动。</li>
              <li>通知服务仅在必填字段完整时可保存。</li>
              <li>运行器支持 JSON 导出与导入。</li>
            </ul>
          </div>
        </div>
      </div>
    </div>

    <script src="/static/app.js?v={{ asset_version }}"></script>
  </body>
</html>
